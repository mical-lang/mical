//! This file is generated by `cargo codegen syntax`, do not edit by hand.
#![cfg_attr(rustfmt, rustfmt::skip)]

use super::{MicalLanguage, SyntaxKind, SyntaxNode, SyntaxToken};
use core::fmt;
pub use rowan::ast::{AstChildren, AstNode};

mod support {
    use super::*;
    pub use rowan::ast::support::*;
    pub struct DebugSyntaxToken(pub Option<SyntaxToken>);
    impl fmt::Debug for DebugSyntaxToken {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match &self.0 {
                Some(token) => fmt::Debug::fmt(token, f),
                None => f.write_str("none"),
            }
        }
    }
    pub struct DebugAstChildren<N: AstNode>(pub AstChildren<N>);
    impl<N: AstNode + fmt::Debug + Clone> fmt::Debug for DebugAstChildren<N> {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_list().entries(self.0.clone().map(|ast| DebugAstNode(Some(ast)))).finish()
        }
    }
    pub struct DebugAstNode<N: AstNode>(pub Option<N>);
    impl<N: AstNode + fmt::Debug + Clone> fmt::Debug for DebugAstNode<N> {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match &self.0 {
                Some(node) => fmt::Debug::fmt(node, f),
                None => f.write_str("none"),
            }
        }
    }
}

#[derive(Clone)]
pub struct SourceFile(SyntaxNode);
impl AstNode for SourceFile {
    type Language = MicalLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::SOURCE_FILE
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> {
        &self.0
    }
}
impl SourceFile {
    pub fn shebang(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::SHEBANG)
    }
    pub fn items(&self) -> AstChildren<Item> {
        support::children(AstNode::syntax(self))
    }
}
impl fmt::Display for SourceFile {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(self.syntax(), f)
    }
}
impl fmt::Debug for SourceFile {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("SourceFile")
            .field("shebang", &support::DebugSyntaxToken(self.shebang()))
            .field("items", &support::DebugAstChildren(self.items()))
            .finish()
    }
}

#[derive(Clone)]
pub enum Item {
    Entry(Entry),
    PrefixBlock(PrefixBlock),
    Directive(Directive),
}
impl AstNode for Item {
    type Language = MicalLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        <Entry as AstNode>::can_cast(kind)
            || <PrefixBlock as AstNode>::can_cast(kind)
            || <Directive as AstNode>::can_cast(kind)
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        let kind = node.kind();
        if <Entry as AstNode>::can_cast(kind) {
            let casted = <Entry as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::Entry(casted));
        }
        if <PrefixBlock as AstNode>::can_cast(kind) {
            let casted = <PrefixBlock as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::PrefixBlock(casted));
        }
        if <Directive as AstNode>::can_cast(kind) {
            let casted = <Directive as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::Directive(casted));
        }
        None
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> {
        match self {
            Self::Entry(x) => x.syntax(),
            Self::PrefixBlock(x) => x.syntax(),
            Self::Directive(x) => x.syntax(),
        }
    }
}
impl fmt::Display for Item {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(self.syntax(), f)
    }
}
impl fmt::Debug for Item {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::Entry(x) => fmt::Debug::fmt(x, f),
            Self::PrefixBlock(x) => fmt::Debug::fmt(x, f),
            Self::Directive(x) => fmt::Debug::fmt(x, f),
        }
    }
}

#[derive(Clone)]
pub struct Entry(SyntaxNode);
impl AstNode for Entry {
    type Language = MicalLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::ENTRY
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> {
        &self.0
    }
}
impl Entry {
    pub fn key(&self) -> Option<Key> {
        support::child(AstNode::syntax(self))
    }
    pub fn value(&self) -> Option<Value> {
        support::child(AstNode::syntax(self))
    }
}
impl fmt::Display for Entry {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(self.syntax(), f)
    }
}
impl fmt::Debug for Entry {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("Entry")
            .field("key", &support::DebugAstNode(self.key()))
            .field("value", &support::DebugAstNode(self.value()))
            .finish()
    }
}

#[derive(Clone)]
pub struct PrefixBlock(SyntaxNode);
impl AstNode for PrefixBlock {
    type Language = MicalLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::PREFIX_BLOCK
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> {
        &self.0
    }
}
impl PrefixBlock {
    pub fn key(&self) -> Option<Key> {
        support::child(AstNode::syntax(self))
    }
    pub fn open_brace(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::OPEN_BRACE)
    }
    pub fn items(&self) -> AstChildren<Item> {
        support::children(AstNode::syntax(self))
    }
    pub fn close_brace(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::CLOSE_BRACE)
    }
}
impl fmt::Display for PrefixBlock {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(self.syntax(), f)
    }
}
impl fmt::Debug for PrefixBlock {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("PrefixBlock")
            .field("key", &support::DebugAstNode(self.key()))
            .field("open_brace", &support::DebugSyntaxToken(self.open_brace()))
            .field("items", &support::DebugAstChildren(self.items()))
            .field("close_brace", &support::DebugSyntaxToken(self.close_brace()))
            .finish()
    }
}

#[derive(Clone)]
pub struct Directive(SyntaxNode);
impl AstNode for Directive {
    type Language = MicalLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::DIRECTIVE
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> {
        &self.0
    }
}
impl Directive {
    pub fn sharp(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::SHARP)
    }
    pub fn name(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::WORD)
    }
    pub fn args(&self) -> Option<LineString> {
        support::child(AstNode::syntax(self))
    }
}
impl fmt::Display for Directive {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(self.syntax(), f)
    }
}
impl fmt::Debug for Directive {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("Directive")
            .field("sharp", &support::DebugSyntaxToken(self.sharp()))
            .field("name", &support::DebugSyntaxToken(self.name()))
            .field("args", &support::DebugAstNode(self.args()))
            .finish()
    }
}

#[derive(Clone)]
pub struct Key(SyntaxNode);
impl AstNode for Key {
    type Language = MicalLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::KEY
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> {
        &self.0
    }
}
impl Key {
    pub fn token(&self) -> Option<SyntaxToken> {
        self.syntax().children_with_tokens().filter_map(|it| it.into_token()).find(|it| {
            matches!(
                it.kind(),
                SyntaxKind::WORD | SyntaxKind::NUMERAL | SyntaxKind::TRUE | SyntaxKind::FALSE | SyntaxKind::STRING
            )
        })
    }
    pub fn kind(&self) -> Option<KeyKind> {
        let token = self.token()?;
        let kind = match token.kind() {
            SyntaxKind::WORD => KeyKind::Word,
            SyntaxKind::NUMERAL => KeyKind::Numeral,
            SyntaxKind::TRUE => KeyKind::True,
            SyntaxKind::FALSE => KeyKind::False,
            SyntaxKind::STRING => KeyKind::String,
            _ => return None,
        };
        Some(kind)
    }
}
pub enum KeyKind {
    Word,
    Numeral,
    True,
    False,
    String,
}
impl fmt::Display for Key {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(self.syntax(), f)
    }
}
impl fmt::Debug for Key {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("Key").field("token", &support::DebugSyntaxToken(self.token())).finish()
    }
}

#[derive(Clone)]
pub enum Value {
    Integer(Integer),
    Boolean(Boolean),
    QuotedString(QuotedString),
    LineString(LineString),
    BlockString(BlockString),
}
impl AstNode for Value {
    type Language = MicalLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        <Integer as AstNode>::can_cast(kind)
            || <Boolean as AstNode>::can_cast(kind)
            || <QuotedString as AstNode>::can_cast(kind)
            || <LineString as AstNode>::can_cast(kind)
            || <BlockString as AstNode>::can_cast(kind)
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        let kind = node.kind();
        if <Integer as AstNode>::can_cast(kind) {
            let casted = <Integer as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::Integer(casted));
        }
        if <Boolean as AstNode>::can_cast(kind) {
            let casted = <Boolean as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::Boolean(casted));
        }
        if <QuotedString as AstNode>::can_cast(kind) {
            let casted = <QuotedString as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::QuotedString(casted));
        }
        if <LineString as AstNode>::can_cast(kind) {
            let casted = <LineString as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::LineString(casted));
        }
        if <BlockString as AstNode>::can_cast(kind) {
            let casted = <BlockString as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::BlockString(casted));
        }
        None
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> {
        match self {
            Self::Integer(x) => x.syntax(),
            Self::Boolean(x) => x.syntax(),
            Self::QuotedString(x) => x.syntax(),
            Self::LineString(x) => x.syntax(),
            Self::BlockString(x) => x.syntax(),
        }
    }
}
impl fmt::Display for Value {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(self.syntax(), f)
    }
}
impl fmt::Debug for Value {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::Integer(x) => fmt::Debug::fmt(x, f),
            Self::Boolean(x) => fmt::Debug::fmt(x, f),
            Self::QuotedString(x) => fmt::Debug::fmt(x, f),
            Self::LineString(x) => fmt::Debug::fmt(x, f),
            Self::BlockString(x) => fmt::Debug::fmt(x, f),
        }
    }
}

#[derive(Clone)]
pub struct LineString(SyntaxNode);
impl AstNode for LineString {
    type Language = MicalLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::LINE_STRING
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> {
        &self.0
    }
}
impl fmt::Display for LineString {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(self.syntax(), f)
    }
}
impl fmt::Debug for LineString {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("LineString").finish()
    }
}

#[derive(Clone)]
pub struct Integer(SyntaxNode);
impl AstNode for Integer {
    type Language = MicalLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::INTEGER
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> {
        &self.0
    }
}
impl Integer {
    pub fn sign(&self) -> Option<SyntaxToken> {
        self.syntax()
            .children_with_tokens()
            .filter_map(|it| it.into_token())
            .find(|it| matches!(it.kind(), SyntaxKind::PLUS | SyntaxKind::MINUS))
    }
    pub fn numeral(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::NUMERAL)
    }
}
impl fmt::Display for Integer {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(self.syntax(), f)
    }
}
impl fmt::Debug for Integer {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("Integer")
            .field("sign", &support::DebugSyntaxToken(self.sign()))
            .field("numeral", &support::DebugSyntaxToken(self.numeral()))
            .finish()
    }
}

#[derive(Clone)]
pub struct Boolean(SyntaxNode);
impl AstNode for Boolean {
    type Language = MicalLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::BOOLEAN
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> {
        &self.0
    }
}
impl Boolean {
    pub fn token(&self) -> Option<SyntaxToken> {
        self.syntax()
            .children_with_tokens()
            .filter_map(|it| it.into_token())
            .find(|it| matches!(it.kind(), SyntaxKind::TRUE | SyntaxKind::FALSE))
    }
    pub fn kind(&self) -> Option<BooleanKind> {
        let token = self.token()?;
        let kind = match token.kind() {
            SyntaxKind::TRUE => BooleanKind::True,
            SyntaxKind::FALSE => BooleanKind::False,
            _ => return None,
        };
        Some(kind)
    }
}
pub enum BooleanKind {
    True,
    False,
}
impl fmt::Display for Boolean {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(self.syntax(), f)
    }
}
impl fmt::Debug for Boolean {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("Boolean").field("token", &support::DebugSyntaxToken(self.token())).finish()
    }
}

#[derive(Clone)]
pub struct QuotedString(SyntaxNode);
impl AstNode for QuotedString {
    type Language = MicalLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::QUOTED_STRING
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> {
        &self.0
    }
}
impl QuotedString {
    pub fn string(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::STRING)
    }
}
impl fmt::Display for QuotedString {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(self.syntax(), f)
    }
}
impl fmt::Debug for QuotedString {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("QuotedString").field("string", &support::DebugSyntaxToken(self.string())).finish()
    }
}

#[derive(Clone)]
pub struct BlockString(SyntaxNode);
impl AstNode for BlockString {
    type Language = MicalLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::BLOCK_STRING
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> {
        &self.0
    }
}
impl BlockString {
    pub fn header(&self) -> Option<BlockStringHeader> {
        support::child(AstNode::syntax(self))
    }
    pub fn lines(&self) -> AstChildren<LineString> {
        support::children(AstNode::syntax(self))
    }
}
impl fmt::Display for BlockString {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(self.syntax(), f)
    }
}
impl fmt::Debug for BlockString {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("BlockString")
            .field("header", &support::DebugAstNode(self.header()))
            .field("lines", &support::DebugAstChildren(self.lines()))
            .finish()
    }
}

#[derive(Clone)]
pub struct BlockStringHeader(SyntaxNode);
impl AstNode for BlockStringHeader {
    type Language = MicalLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::BLOCK_STRING_HEADER
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> {
        &self.0
    }
}
impl BlockStringHeader {
    pub fn style(&self) -> Option<SyntaxToken> {
        self.syntax()
            .children_with_tokens()
            .filter_map(|it| it.into_token())
            .find(|it| matches!(it.kind(), SyntaxKind::PIPE | SyntaxKind::GT))
    }
    pub fn chomp(&self) -> Option<SyntaxToken> {
        self.syntax()
            .children_with_tokens()
            .filter_map(|it| it.into_token())
            .find(|it| matches!(it.kind(), SyntaxKind::PLUS | SyntaxKind::MINUS))
    }
    pub fn indent(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::NUMERAL)
    }
}
impl fmt::Display for BlockStringHeader {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(self.syntax(), f)
    }
}
impl fmt::Debug for BlockStringHeader {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("BlockStringHeader")
            .field("style", &support::DebugSyntaxToken(self.style()))
            .field("chomp", &support::DebugSyntaxToken(self.chomp()))
            .field("indent", &support::DebugSyntaxToken(self.indent()))
            .finish()
    }
}
