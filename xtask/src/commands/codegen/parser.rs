use super::{ensure_file_contents, rustfmt};
use crate::project_root;

use anyhow::Result;
use quote::{format_ident, quote};
use std::fs;
use xshell::Shell;

const GENERATED_HEADER: &str = r##"
//! This file is generated by `cargo codegen parser`, do not edit by hand.
#![cfg_attr(rustfmt, rustfmt::skip)]
"##;

pub(crate) fn generate(sh: &Shell, check: bool) -> Result<()> {
    let cases_dir = project_root().join("crates/parser/tests/cases");
    let tests_dir = project_root().join("crates/parser/tests");

    // Collect top-level .mical files and subdirectories
    let mut top_level_cases: Vec<String> = Vec::new();
    let mut subdirs: Vec<String> = Vec::new();

    for entry in fs::read_dir(&cases_dir)? {
        let entry = entry?;
        let path = entry.path();
        if path.is_dir() {
            if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
                subdirs.push(name.to_owned());
            }
        } else if path.extension().is_some_and(|e| e == "mical")
            && let Some(stem) = path.file_stem().and_then(|n| n.to_str())
        {
            top_level_cases.push(stem.to_owned());
        }
    }

    top_level_cases.sort();
    subdirs.sort();

    // Generate snapshots.rs for top-level cases
    {
        let test_fns = top_level_cases.iter().map(|case| {
            let fn_name = format_ident!("{case}");
            let include_path = format!("./cases/{case}.mical");
            quote! {
                #[test]
                fn #fn_name() {
                    let source = include_str!(#include_path);
                    let snapshot = utils::make_snapshot(#case, source);
                    utils::assert_snapshot!("", snapshot);
                }
            }
        });
        let code = quote! {
            mod utils;
            #(#test_fns)*
        };
        let formatted = rustfmt(sh, code.to_string())?;
        ensure_file_contents(
            &tests_dir.join("snapshots.rs"),
            &format!("{}\n{}", GENERATED_HEADER.trim_start(), formatted),
            check,
        )?;
    }

    // Generate snapshots_{dir}.rs for each subdirectory
    for dir in &subdirs {
        let dir_path = cases_dir.join(dir);
        let mut cases: Vec<String> = Vec::new();

        for entry in fs::read_dir(&dir_path)? {
            let entry = entry?;
            let path = entry.path();
            if path.extension().is_some_and(|e| e == "mical")
                && let Some(stem) = path.file_stem().and_then(|n| n.to_str())
            {
                cases.push(stem.to_owned());
            }
        }

        cases.sort();

        let test_fns = cases.iter().map(|case| {
            let fn_name = format_ident!("{case}");
            let include_path = format!("./cases/{dir}/{case}.mical");
            let snapshot_name = format!("{dir}/{case}");
            quote! {
                #[test]
                fn #fn_name() {
                    let source = include_str!(#include_path);
                    let snapshot = utils::make_snapshot(#snapshot_name, source);
                    utils::assert_snapshot!(GROUP, snapshot);
                }
            }
        });
        let code = quote! {
            mod utils;
            const GROUP: &str = #dir;
            #(#test_fns)*
        };
        let formatted = rustfmt(sh, code.to_string())?;
        ensure_file_contents(
            &tests_dir.join(format!("snapshots_{dir}.rs")),
            &format!("{}\n{}", GENERATED_HEADER.trim_start(), formatted),
            check,
        )?;
    }

    Ok(())
}
