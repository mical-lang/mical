use super::{ensure_file_contents, rustfmt};
use crate::project_root;

use anyhow::Result;
use convert_case::{Case, Casing};
use proc_macro2::{Punct, Spacing, TokenStream};
use quote::{format_ident, quote};
use std::fs;
use ungrammar::{Grammar, NodeData, Rule};
use xshell::Shell;

const GENERATED_HEADER: &str = r##"
//! This file is generated by `cargo codegen syntax`, do not edit by hand.
#![cfg_attr(rustfmt, rustfmt::skip)]
"##;

pub(crate) fn generate(sh: &Shell, check: bool) -> Result<()> {
    let source = fs::read_to_string(project_root().join("crates/syntax/mical.ungram"))?;
    let grammar = source.parse::<Grammar>()?;
    ensure_file_contents(
        &project_root().join("crates/syntax/src/syntax_kind.rs"),
        &format!("{}\n{}", GENERATED_HEADER.trim_start(), rustfmt(sh, syntax_kind_rs(&grammar))?),
        check,
    )?;
    ensure_file_contents(
        &project_root().join("crates/syntax/src/ast.rs"),
        &format!("{}\n{}", GENERATED_HEADER.trim_start(), rustfmt(sh, ast_rs(&grammar))?),
        check,
    )?;
    Ok(())
}

static PUNCT_NAME_MAP: phf::Map<&str, &str> = phf::phf_map! {
    "#" => "sharp",
    "+" => "plus",
    "-" => "minus",
    ">" => "gt",
    "{" => "open_brace",
    "|" => "pipe",
    "}" => "close_brace",
};

fn syntax_kind_rs(grammar: &Grammar) -> String {
    let all_nodes_name = {
        let iter1 = ["ERROR", "COMMENT"].into_iter().map(|s| format_ident!("{s}"));
        let iter2 = grammar.iter().filter_map(|node| {
            let generate = match &grammar[node].rule {
                Rule::Alt(alts) => {
                    let has_token = alts.iter().any(|r| matches!(r, Rule::Token(_)));
                    let has_node = alts.iter().any(|r| matches!(r, Rule::Node(_)));
                    match (has_token, has_node) {
                        (true, false) => true,
                        (false, true) => false,
                        _ => panic!("complex/mixed Alt in {}", grammar[node].name),
                    }
                }
                _ => true,
            };
            if generate {
                let name = &grammar[node].name;
                Some(format_ident!("{}", name.to_case(Case::UpperSnake)))
            } else {
                None
            }
        });
        let mut vec = iter1.chain(iter2).collect::<Vec<_>>();
        vec.sort_unstable();
        vec
    };
    let all_token_name = {
        let iter1 =
            ["TAB", "NEWLINE", "SPACE", "BACKSLASH"].into_iter().map(|s| format_ident!("{s}"));
        let iter2 = grammar.tokens().filter_map(|token| {
            let name = &grammar[token].name;
            if name.starts_with('@') {
                return None;
            }
            if let Some(name) = name.strip_prefix('$') {
                return Some(format_ident!("{}", name.to_case(Case::UpperSnake)));
            }
            if let Some(name) = PUNCT_NAME_MAP.get(name) {
                return Some(format_ident!("{}", name.to_case(Case::UpperSnake)));
            }
            panic!("Unknown token for SyntaxKind: {}", name);
        });
        let mut vec = iter1.chain(iter2).collect::<Vec<_>>();
        vec.sort_unstable();
        vec
    };
    let all_token_short_map_arm = {
        let iter1 = [('\t', "TAB"), ('\n', "NEWLINE"), (' ', "SPACE"), ('\\', "BACKSLASH")]
            .into_iter()
            .map(|(p, name)| {
                let variant = format_ident!("{name}");
                quote! { (#p) => { $crate::SyntaxKind::#variant } }
            });
        let iter2 = grammar.tokens().filter_map(|token| {
            let name = &grammar[token].name;
            if name.starts_with('@') {
                return None;
            }
            if let Some(name) = name.strip_prefix('$') {
                let variant = format_ident!("{}", name.to_case(Case::UpperSnake));
                let name = format_ident!("{name}");
                return Some(quote! { (#name) => { $crate::SyntaxKind::#variant } });
            }
            if let Some(punct_name) = PUNCT_NAME_MAP.get(name) {
                let variant = format_ident!("{}", punct_name.to_case(Case::UpperSnake));
                let punct = match name.as_str() {
                    "{" | "}" => {
                        let c = name.chars().next().unwrap();
                        quote! { #c }
                    }
                    _ => {
                        let ps = name.chars().map(|c| Punct::new(c, Spacing::Joint));
                        quote! { #(#ps)* }
                    }
                };
                return Some(quote! { (#punct) => { $crate::SyntaxKind::#variant } });
            }
            panic!("Unknown token for SyntaxKind: {}", name);
        });
        iter1.chain(iter2)
    };
    let syntax_kind_def = quote! {
        #[allow(bad_style)]
        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
        #[repr(u8)]
        pub enum SyntaxKind {
            #(#all_token_name,)*
            #(#all_nodes_name,)*
        }
    };
    let syntax_kind_impl = {
        let total_count = all_token_name.len() + all_nodes_name.len();
        quote! {
            impl SyntaxKind {
                pub const COUNT: usize = #total_count;
            }
            impl From<SyntaxKind> for ::rowan::SyntaxKind {
                fn from(kind: SyntaxKind) -> Self {
                    Self(kind as u16)
                }
            }
            impl From<::rowan::SyntaxKind> for SyntaxKind {
                fn from(kind: ::rowan::SyntaxKind) -> Self {
                    assert!(kind.0 < (#total_count as u16), "bad SyntaxKind: {:?}", kind);
                    unsafe { ::core::mem::transmute(kind.0 as u8) }
                }
            }
        }
    };
    let token_fast_access_macro = quote! {
        #[macro_export]
        #[doc(hidden)]
        macro_rules! __token_kind_fast_accsess {
            #(#all_token_short_map_arm);*
        }
        pub use __token_kind_fast_accsess as T;
    };
    format!("{syntax_kind_def}\n\n{syntax_kind_impl}\n\n{token_fast_access_macro}")
}

fn ast_rs(grammar: &Grammar) -> String {
    let use_code = quote! {
        use super::{MicalLanguage, SyntaxKind, SyntaxNode, SyntaxToken};
        use core::fmt;
        pub use rowan::ast::{AstNode, AstChildren};
    };
    let support_mod_code = quote! {
        mod support {
            use super::*;
            pub use rowan::ast::support::*;
            pub struct DebugSyntaxToken(pub Option<SyntaxToken>);
            impl fmt::Debug for DebugSyntaxToken {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    match &self.0 {
                        Some(token) => fmt::Debug::fmt(token, f),
                        None => f.write_str("none")
                    }
                }
            }
            pub struct DebugAstChildren<N: AstNode>(pub AstChildren<N>);
            impl<N: AstNode + fmt::Debug + Clone> fmt::Debug for DebugAstChildren<N> {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.debug_list().entries(self.0.clone().map(|ast| DebugAstNode(Some(ast)))).finish()
                }
            }
            pub struct DebugAstNode<N: AstNode>(pub Option<N>);
            impl<N: AstNode + fmt::Debug + Clone> fmt::Debug for DebugAstNode<N> {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    match &self.0 {
                        Some(node) => fmt::Debug::fmt(node, f),
                        None => f.write_str("none")
                    }
                }
            }
        }
    };
    let ast_nodes_code = {
        let iter = grammar.iter().map(|node| {
            let node = &grammar[node];
            match &node.rule {
                Rule::Node(_) | Rule::Seq(_) => convert_node_to_struct(node, grammar),
                Rule::Token(t) => {
                    if grammar[*t].name.starts_with('@') {
                        convert_special_token_node(node, grammar)
                    } else {
                        convert_node_to_struct(node, grammar)
                    }
                }
                Rule::Alt(alts) => {
                    let has_token = alts.iter().any(|r| matches!(r, Rule::Token(_)));
                    let has_node = alts.iter().any(|r| matches!(r, Rule::Node(_)));
                    match (has_token, has_node) {
                        (true, false) => convert_token_alt_to_struct(node, grammar),
                        (false, true) => convert_node_to_enum(node, grammar),
                        _ => panic!("complex/mixed Alt in {}", node.name),
                    }
                }
                _ => panic!("unexpected rule in AST generation"),
            }
        });
        iter.map(|ts| format!("{ts}")).collect::<Vec<_>>().join("\n\n")
    };
    format!("{use_code}\n\n{support_mod_code}\n\n{ast_nodes_code}")
}

fn convert_node_to_struct(node: &NodeData, grammar: &Grammar) -> TokenStream {
    assert!(matches!(node.rule, Rule::Seq(_) | Rule::Node(_) | Rule::Token(_)));
    let name = node.name.to_case(Case::Pascal);
    let fields = match &node.rule {
        rule @ Rule::Node(_) => vec![rule],
        rule @ Rule::Token(_) => vec![rule],
        Rule::Seq(vec) => vec.iter().collect(),
        _ => unreachable!(),
    };
    #[derive(Default)]
    struct TokenStreamBuildHelper {
        field_token_stream: Vec<TokenStream>,
        debug_token_stream: Vec<TokenStream>,
    }
    impl TokenStreamBuildHelper {
        fn push_child(&mut self, field_name_str: &str, field_ty: &str) {
            let field_name = format_ident!("{field_name_str}");
            let field_ty = format_ident!("{field_ty}");
            self.field_token_stream.push(quote! {
                pub fn #field_name(&self) -> Option<#field_ty> {
                    support::child(AstNode::syntax(self))
                }
            });
            self.debug_token_stream.push(quote! {
                .field(#field_name_str, &support::DebugAstNode(self.#field_name()))
            })
        }
        fn push_token(&mut self, field_name_str: &str, syntax_kind_str: &str) {
            let field_name = format_ident!("{field_name_str}");
            let syntax_kind = format_ident!("{syntax_kind_str}");
            self.field_token_stream.push(quote! {
                pub fn #field_name(&self) -> Option<SyntaxToken> {
                    support::token(AstNode::syntax(self), SyntaxKind::#syntax_kind)
                }
            });
            self.debug_token_stream.push(quote! {
                .field(#field_name_str, &support::DebugSyntaxToken(self.#field_name()))
            })
        }
        fn push_children(&mut self, field_name_str: &str, field_ty: &str) {
            let field_name = format_ident!("{field_name_str}");
            let field_ty = format_ident!("{field_ty}");
            self.field_token_stream.push(quote! {
                pub fn #field_name(&self) -> AstChildren<#field_ty> {
                    support::children(AstNode::syntax(self))
                }
            });
            self.debug_token_stream.push(quote! {
                .field(#field_name_str, &support::DebugAstChildren(self.#field_name()))
            })
        }
        fn push_token_alt(&mut self, field_name_str: &str, syntax_kinds: &[String]) {
            let field_name = format_ident!("{field_name_str}");
            let syntax_kinds_ident: Vec<_> =
                syntax_kinds.iter().map(|s| format_ident!("{s}")).collect();
            self.field_token_stream.push(quote! {
                pub fn #field_name(&self) -> Option<SyntaxToken> {
                    self.syntax()
                        .children_with_tokens()
                        .filter_map(|it| it.into_token())
                        .find(|it| matches!(it.kind(), #(SyntaxKind::#syntax_kinds_ident)|*))
                }
            });
            self.debug_token_stream.push(quote! {
                .field(#field_name_str, &support::DebugSyntaxToken(self.#field_name()))
            })
        }
    }
    let mut build_helper = TokenStreamBuildHelper::default();
    for mut field in fields {
        while let Rule::Opt(next) = field {
            field = next;
        }
        match field {
            Rule::Labeled { label, rule } => {
                let mut rule = &**rule;
                while let Rule::Opt(next) = rule {
                    rule = next;
                }
                let field_name = label.to_case(Case::Snake);
                match rule {
                    Rule::Node(node) => {
                        let field_ty = grammar[*node].name.to_case(Case::UpperCamel);
                        build_helper.push_child(&field_name, &field_ty);
                    }
                    Rule::Token(token) => {
                        let name = &grammar[*token].name;
                        let syntax_kind = if let Some(name) = name.strip_prefix('$') {
                            name.to_case(Case::UpperSnake)
                        } else if let Some(name) = PUNCT_NAME_MAP.get(name) {
                            name.to_case(Case::UpperSnake)
                        } else {
                            panic!("Unknown token for field {:?} in {}", field, name)
                        };
                        build_helper.push_token(&field_name, &syntax_kind);
                    }
                    Rule::Rep(rule) => {
                        let Rule::Node(node) = &**rule else {
                            panic!("complex rule {:?} in {}", rule, name)
                        };
                        let field_ty = grammar[*node].name.to_case(Case::UpperCamel);
                        build_helper.push_children(&field_name, &field_ty);
                    }
                    Rule::Seq(_) => panic!("complex rule {:?} in {}", field, name),
                    Rule::Alt(rules) => {
                        let syntax_kinds: Vec<String> = rules
                            .iter()
                            .map(|rule| match rule {
                                Rule::Token(token) => {
                                    let tok_name = &grammar[*token].name;
                                    if let Some(name) = tok_name.strip_prefix('$') {
                                        name.to_case(Case::UpperSnake)
                                    } else if let Some(name) = PUNCT_NAME_MAP.get(tok_name) {
                                        name.to_case(Case::UpperSnake)
                                    } else {
                                        panic!("Unknown token {:?} in {}", tok_name, name)
                                    }
                                }
                                _ => panic!("complex rule {:?} in {}", rules, name),
                            })
                            .collect();
                        build_helper.push_token_alt(&field_name, &syntax_kinds);
                    }
                    Rule::Labeled { .. } => panic!("complex rule {:?} in {}", rule, name),
                    Rule::Opt(_) => unreachable!(),
                }
            }
            Rule::Node(node) => {
                let field_name = grammar[*node].name.to_case(Case::Snake);
                let field_ty = grammar[*node].name.to_case(Case::UpperCamel);
                build_helper.push_child(&field_name, &field_ty);
            }
            Rule::Token(token) => {
                let field_name = {
                    let name = &grammar[*token].name;
                    if let Some(name) = name.strip_prefix('$') {
                        name.to_case(Case::Snake)
                    } else if let Some(name) = PUNCT_NAME_MAP.get(name) {
                        name.to_case(Case::Snake)
                    } else {
                        panic!("Unknown token for field {:?} in {}", field, name)
                    }
                };
                let syntax_kind = field_name.to_case(Case::UpperSnake);
                build_helper.push_token(&field_name, &syntax_kind);
            }
            Rule::Seq(_) => panic!("complex rule {:?} in {}", field, name),
            Rule::Alt(_) => panic!("complex rule {:?} in {}", field, name),
            Rule::Rep(rule) => {
                let Rule::Node(node) = &**rule else {
                    panic!("complex rule {:?} in {}", rule, name)
                };
                let field_name = grammar[*node].name.to_case(Case::Snake);
                let field_ty = grammar[*node].name.to_case(Case::UpperCamel);
                build_helper.push_children(&field_name, &field_ty);
            }
            Rule::Opt(_) => unreachable!(),
        }
    }
    let fields = build_helper.field_token_stream;
    let debug_fields = build_helper.debug_token_stream;
    let syntax_kind = format_ident!("{}", name.to_case(Case::UpperSnake));
    let name_string = name.clone();
    let name = format_ident!("{name}");
    quote! {
        #[derive(Clone)]
        pub struct #name(SyntaxNode);
        impl AstNode for #name {
            type Language = MicalLanguage;
            fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
                kind == SyntaxKind::#syntax_kind
            }
            fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
                if Self::can_cast(node.kind()) {
                    Some(Self(node))
                } else {
                    None
                }
            }
            fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
        }
        impl #name {
            #(#fields)*
        }
        impl fmt::Display for #name {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                fmt::Display::fmt(self.syntax(), f)
            }
        }
        impl fmt::Debug for #name {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.debug_struct(#name_string)
                    #(#debug_fields)*
                    .finish()
            }
        }
    }
}

fn convert_node_to_enum(node: &NodeData, grammar: &Grammar) -> TokenStream {
    assert!(matches!(node.rule, Rule::Alt(_)));
    let name = node.name.to_case(Case::Pascal);
    let (variant_names, variant_ty_names) = {
        let mut names = Vec::new();
        let mut ty_names = Vec::new();
        let Rule::Alt(variants) = &node.rule else { unreachable!() };
        for variant in variants {
            match variant {
                Rule::Labeled { label, rule } => match &**rule {
                    Rule::Node(node) => {
                        let name = label.to_case(Case::UpperCamel);
                        let ty_name = grammar[*node].name.to_case(Case::UpperCamel);
                        names.push(format_ident!("{name}"));
                        ty_names.push(format_ident!("{ty_name}"));
                    }
                    _ => panic!("complex rule {:?} in {}", rule, name),
                },
                Rule::Node(node) => {
                    let node_name = &grammar[*node].name;
                    let name = match node_name.strip_suffix(&name) {
                        Some(name) => name.to_case(Case::UpperCamel),
                        None => node_name.to_case(Case::UpperCamel),
                    };
                    let ty_name = node_name.to_case(Case::UpperCamel);
                    names.push(format_ident!("{name}"));
                    ty_names.push(format_ident!("{ty_name}"));
                }
                Rule::Token(_) => panic!(
                    "token-only Alt should use convert_token_alt_to_struct, found in {}",
                    name
                ),
                _ => panic!("complex rule {variant:?} in {name}"),
            }
        }
        (names, ty_names)
    };
    let name = format_ident!("{name}");
    quote! {
        #[derive(Clone)]
        pub enum #name {
            #(#variant_names(#variant_ty_names)),*
        }
        impl AstNode for #name {
            type Language = MicalLanguage;
            fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
                #(<#variant_ty_names as AstNode>::can_cast(kind))||*
            }
            fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
                let kind = node.kind();
                #(if <#variant_ty_names as AstNode>::can_cast(kind) {
                    let casted = <#variant_ty_names as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
                    return Some(Self::#variant_names(casted));
                })*
                None
            }
            fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> {
                match self {
                    #(Self::#variant_names(x) => x.syntax()),*
                }
            }
        }
        impl fmt::Display for #name {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
        }
        impl fmt::Debug for #name {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                match self {
                    #(Self::#variant_names(x) => fmt::Debug::fmt(x, f)),*
                }
            }
        }
    }
}

fn convert_special_token_node(node: &NodeData, grammar: &Grammar) -> TokenStream {
    assert!(matches!(node.rule, Rule::Token(_)));
    let Rule::Token(token) = &node.rule else { unreachable!() };
    let token_name = &grammar[*token].name;
    assert!(token_name.starts_with('@'));
    if token_name != "@string" {
        panic!("unsupported special token {token_name:?} in {}", node.name);
    }
    let name = node.name.to_case(Case::Pascal);
    let syntax_kind = format_ident!("{}", name.to_case(Case::UpperSnake));
    let name_string = name.clone();
    let name = format_ident!("{name}");
    quote! {
        #[derive(Clone)]
        pub struct #name(SyntaxNode);
        impl AstNode for #name {
            type Language = MicalLanguage;
            fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
                kind == SyntaxKind::#syntax_kind
            }
            fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
                if Self::can_cast(node.kind()) {
                    Some(Self(node))
                } else {
                    None
                }
            }
            fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
        }
        impl fmt::Display for #name {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                fmt::Display::fmt(self.syntax(), f)
            }
        }
        impl fmt::Debug for #name {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.debug_struct(#name_string).finish()
            }
        }
    }
}

fn convert_token_alt_to_struct(node: &NodeData, grammar: &Grammar) -> TokenStream {
    assert!(matches!(node.rule, Rule::Alt(_)));
    let Rule::Alt(alts) = &node.rule else { unreachable!() };
    let name = node.name.to_case(Case::Pascal);
    let syntax_kind_names = {
        let iter = alts.iter().map(|rule| {
            let Rule::Token(token) = rule else {
                panic!("non-token variant in token-only Alt {name}");
            };
            let tok_name = &grammar[*token].name;
            let syntax_kind_name = if let Some(stripped) = tok_name.strip_prefix('$') {
                stripped.to_case(Case::UpperSnake)
            } else if let Some(punct_name) = PUNCT_NAME_MAP.get(tok_name) {
                punct_name.to_case(Case::UpperSnake)
            } else {
                panic!("Unknown token {tok_name:?} in {name}")
            };
            format_ident!("{syntax_kind_name}")
        });
        iter.collect::<Vec<_>>()
    };
    let token_method = quote! {
        pub fn token(&self) -> Option<SyntaxToken> {
            self.syntax()
                .children_with_tokens()
                .filter_map(|it| it.into_token())
                .find(|it| matches!(it.kind(), #(SyntaxKind::#syntax_kind_names)|*))
        }
    };
    let (kind_method, kind_enum) = if syntax_kind_names.len() > 1 {
        let kind_name = format_ident!("{name}Kind");
        let kind_variants: Vec<_> = syntax_kind_names
            .iter()
            .map(|sk| format_ident!("{}", sk.to_string().to_case(Case::Pascal)))
            .collect();
        let method = quote! {
            pub fn kind(&self) -> Option<#kind_name> {
                let token = self.token()?;
                let kind = match token.kind() {
                    #(SyntaxKind::#syntax_kind_names => #kind_name::#kind_variants,)*
                    _ => return None,
                };
                Some(kind)
            }
        };
        let enum_def = quote! {
            pub enum #kind_name {
                #(#kind_variants),*
            }
        };
        (method, enum_def)
    } else {
        (quote! {}, quote! {})
    };
    let syntax_kind = format_ident!("{}", name.to_case(Case::UpperSnake));
    let name_string = name.clone();
    let name_ident = format_ident!("{name}");
    quote! {
        #[derive(Clone)]
        pub struct #name_ident(SyntaxNode);
        impl AstNode for #name_ident {
            type Language = MicalLanguage;
            fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
                kind == SyntaxKind::#syntax_kind
            }
            fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
                if Self::can_cast(node.kind()) {
                    Some(Self(node))
                } else {
                    None
                }
            }
            fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
        }
        impl #name_ident {
            #token_method
            #kind_method
        }
        #kind_enum
        impl fmt::Display for #name_ident {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                fmt::Display::fmt(self.syntax(), f)
            }
        }
        impl fmt::Debug for #name_ident {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.debug_struct(#name_string)
                    .field("token", &support::DebugSyntaxToken(self.token()))
                    .finish()
            }
        }
    }
}
